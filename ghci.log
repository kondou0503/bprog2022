GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /Users/nanami/bprog2022/.ghci
2022-05-19 15:44:08.395768
>>> 5+4
9
2022-05-19 15:54:07.242034
>>> 2+3*4
14
2022-05-19 15:54:31.991708
>>> 8/4
2.0
2022-05-19 15:54:55.137111
>>> (2+3)*4
20
2022-05-19 15:55:20.466548
>>> 10-7
3
2022-05-19 15:55:28.826396
>>> 3 - 9 -4
-10
2022-05-19 15:55:39.130482
>>> 20+5*2-6
24
2022-05-19 15:56:43.043511
>>> 2 - 3 -1
-2
2022-05-19 15:57:18.785728
>>> 2 - (3 - 1)
0
2022-05-19 15:57:25.501519
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:42.035817
>>> sqrt 16
4.0
2022-05-19 16:00:25.427338
>>> double 3

<interactive>:12:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:00.410939
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /Users/nanami/bprog2022/.ghci
2022-06-16 14:48:56.144236
>>> :e src/First.hs
:l src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 14:54:25.330105
>>> [1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 14:54:25.340255
>>> double 3
6
2022-06-16 14:54:38.988163
>>> quadruple 3
12
2022-06-16 14:54:50.505062
>>> hoge = 3,1,4,1,5 :: Int

<interactive>:5:9: error: parse error on input ‘,’
2022-06-16 14:56:19.708183
>>> head [1,2,3,4,5]
1
2022-06-16 14:56:40.370869
>>> product [1,2,3,4,5]
120
2022-06-16 14:57:01.699628
>>> double 2 + double 3
10
2022-06-16 14:57:24.114214
>>> double (3 + 2)
10
2022-06-16 14:58:07.308827
>>> double 3 + 2
8
2022-06-16 14:58:20.607957
>>> take 3 {3,1,4,1,5]

<interactive>:11:9: error: parse error on input ‘3’
2022-06-16 15:01:18.786305
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:01:35.01401
>>> take (double 2) [3,1,4,1,5]
[3,1,4,1]
2022-06-16 15:04:48.508372
>>> quadruple (5+3)
32
2022-06-16 15:10:36.304322
>>> 
2022-06-16 15:12:06.30948
>>> 
2022-06-16 15:12:57.27657
>>> double

<interactive>:17:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:13:05.816261
>>> doule

<interactive>:18:1: error:
    • Variable not in scope: doule
    • Perhaps you meant ‘double’ (line 4)
2022-06-16 15:13:19.043987
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:13.235139
>>> take (double 3) [7,6,5,3,1,5,2,8,3]
[7,6,5,3,1,5]
2022-06-16 15:16:04.679774
>>> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:20:08.336266
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:20:58.545555
>>> factorial 3
6
2022-06-16 15:22:08.116405
>>> factorial 5
120
2022-06-16 15:22:16.868809
>>> 
2022-06-16 15:38:08.535724
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs =sum xs `div' length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs)(length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:26: error: parse error on input ‘length’
   |
13 | average xs =sum xs `div' length xs
   |                          ^^^^^^
Failed, no modules loaded.
2022-06-16 15:38:10.130234
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div' length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs)(length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:27: error: parse error on input ‘length’
   |
13 | average xs = sum xs `div' length xs
   |                           ^^^^^^
Failed, no modules loaded.
2022-06-16 15:39:46.416905
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div' length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:27: error: parse error on input ‘length’
   |
13 | average xs = sum xs `div' length xs
   |                           ^^^^^^
Failed, no modules loaded.
2022-06-16 15:40:29.881096
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:40:47.097104
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:50:04.336462
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:06:59.0608
>>> init 2

<interactive>:32:1: error:
    • Non type-variable argument in the constraint: Num [a]
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall {a}. Num [a] => [a]
2022-06-16 16:11:40.005575
>>> init [2]
[]
2022-06-16 16:11:56.013513
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit [x] = []
  20  myinit (x:xs) = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:14:24.249399
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:14:36.517137
>>> myinit []
*** Exception: src/First.hs:(19,1)-(20,29): Non-exhaustive patterns in function myinit

2022-06-16 16:14:57.116544
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /Users/nanami/bprog2022/.ghci
2022-06-23 14:54:36.632357
>>> :i
syntax: ':i <thing-you-want-info-about>'
2022-06-23 14:54:52.610814
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:56:27.543744
>>> 1 == 2
False
2022-06-23 15:06:10.860995
>>> 1 < 2
True
2022-06-23 15:06:16.179174
>>> 1 < 1
False
2022-06-23 15:06:26.120359
>>> 1 <= 2
True
2022-06-23 15:06:36.041371
>>> 1 >= 2
False
2022-06-23 15:06:43.734476
>>> 'a' < 'b'
True
2022-06-23 15:11:18.087842
>>> 'a' < 'B'
False
2022-06-23 15:11:29.145471
>>> 'B' < 'a'
True
2022-06-23 15:11:43.986294
>>> 'a' < ''

<interactive>:11:7: error:
    Parser error on `''`
    Character literals may not be empty
2022-06-23 15:12:01.259998
>>> 1 /= 2
True
2022-06-23 15:16:27.446589
>>> 1/= 1
False
2022-06-23 15:16:35.034272
>>> :info abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:11.919623
>>> abs

<interactive>:15:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:30:49.429171
>>> abs (-234)
234
2022-06-23 15:34:32.693465
>>> 
2022-06-23 15:38:39.487813
>>> 
2022-06-23 15:40:15.390374
>>> 
2022-06-23 15:40:38.665239
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /Users/nanami/bprog2022/.ghci
2022-06-30 14:56:26.632193
>>> [ x^ 2 | x <- [1 .. 5]]
[1,4,9,16,25]
2022-06-30 15:01:57.190559
>>> mao (^2) [1 .. 5]

<interactive>:2:1: error:
    • Variable not in scope: mao :: (a0 -> a0) -> [a1] -> t
    • Perhaps you meant one of these:
        ‘map’ (imported from Prelude), ‘max’ (imported from Prelude)
2022-06-30 15:04:09.347391
>>> map (^2) [1 .. 5]
[1,4,9,16,25]
2022-06-30 15:04:25.374857
>>> [ x * 2 | x <- [1 .. 5]

<interactive>:4:24: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-30 15:12:07.561329
>>> [x * 2 | x <- [1 .. 5]]
[2,4,6,8,10]
2022-06-30 15:12:22.671477
>>> [ x `div` 2 | x <- [1 .. 5]]
[0,1,1,2,2]
2022-06-30 15:13:26.501512
>>> [ x `divMod` 2 | x <- [1 .. 5]]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-06-30 15:16:13.661553
>>> [ (x, y) | x <- "abc", y <- [4,5] ]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-06-30 15:20:54.976108
>>> [ (x, y) | y <- [4, 5], x<- "abc" ]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-06-30 15:21:55.207854
>>> :e
No files to edit.
2022-06-30 15:26:34.644552
>>> :e
No files to edit.
2022-06-30 15:26:37.823495
>>> :l
Ok, no modules loaded.
2022-06-30 15:26:37.935996
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]

<interactive>:13:1: error:
    • Variable not in scope: myconcat :: [[a0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-06-30 15:27:24.678656
>>> :e
No files to edit.
2022-06-30 15:27:40.46288
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit [x] = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
Ok, no modules loaded.
2022-06-30 15:29:31.995134
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:29:32.10986
>>>  myconcat [[1,2,3],[4,5],[6,7,8,9]]
[1,2,3,4,5,6,7,8,9]
2022-06-30 15:37:14.959931
>>> [1 | _ <- [1 .. 5] ]
[1,1,1,1,1]
2022-06-30 15:47:34.214816
>>> [2 | _ <- [1 .. 5] ]
[2,2,2,2,2]
2022-06-30 15:48:05.555368
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit [x] = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [1 | _ <- xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:50:01.53163
>>> mylength ['a' .. 'z']
26
2022-06-30 15:50:30.128368
>>> ['a' .. 'z']
"abcdefghijklmnopqrstuvwxyz"
2022-06-30 15:50:57.714569
>>> putStrLn it
abcdefghijklmnopqrstuvwxyz
2022-06-30 15:52:52.636338
>>> ['あ' ..'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:53:21.814172
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-06-30 15:53:33.585337
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /Users/nanami/bprog2022/.ghci
2022-07-14 15:11:18.253799
>>> a:l src/Caesar.hs

<interactive>:1:9: error:
    Not in scope: ‘Caesar.hs’
    No module named ‘Caesar’ is imported.
2022-07-14 15:11:34.265925
>>> :e src/Caesar.hs
:l src/Caesar.hs
   1  module Caesar where
   2  
   3  import Date.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c
Ok, no modules loaded.
2022-07-14 15:12:54.022551
>>> [1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 15:12:54.029331
>>> let2int 'a'

<interactive>:4:1: error:
    Variable not in scope: let2int :: Char -> t
2022-07-14 15:13:13.415504
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /Users/nanami/bprog2022/.ghci
2022-07-21 15:08:33.150023
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Date.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String i> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
Ok, no modules loaded.
2022-07-21 15:08:55.290124
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:08:55.383499
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Date.Char
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:13:21.869896
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:13:21.934922
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String i> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:31:18: error:
    Not in scope: type constructor or class ‘>’
   |
31 | freqs :: String i> [Float]
   |                  ^

src/Caesar.hs:31:18: error:
    Illegal operator ‘>’ in type ‘String i > [Float]’
      Use TypeOperators to allow operators in types
   |
31 | freqs :: String i> [Float]
   |                  ^
Failed, no modules loaded.
2022-07-21 15:16:54.921064
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:17:33.849852
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:19:25.232738
>>> length sample
15
2022-07-21 15:19:53.444658
>>> sample
"abbcccddddeeeee"
2022-07-21 15:19:56.726879
>>> freqs sample
[6.666667,13.333334,20.0,26.666668,33.333336,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
2022-07-21 15:20:14.876552
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ ( (o-e)^2 ) / e | (o, e) <- zip os es]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:38:54.76327
>>> rotate 3 [1 .. 6]
[4,5,6,1,2,3]
2022-07-21 15:39:36.770116
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ ( (o-e)^2 ) / e | (o, e) <- zip os es]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs "kdvnhoo lv ixq"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:46:06.410481
>>> table'
[0.0,0.0,0.0,7.1428576,0.0,0.0,0.0,7.1428576,7.1428576,0.0,7.1428576,7.1428576,0.0,7.1428576,14.285715,0.0,7.1428576,0.0,0.0,0.0,0.0,14.285715,0.0,7.1428576,0.0,0.0]
2022-07-21 15:46:17.743815
>>> [chisqr (rotate n table') table | n <- [0 .. 25]

<interactive>:15:49: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-07-21 15:47:47.102168
>>>  [chisqr (rotate n table') table | n <- [0 .. 25]]
[1037.1161,472.26096,451.96503,150.75772,1059.9601,3122.5193,480.326,857.7907,716.2974,731.72504,367.52783,1095.8976,1689.1488,1036.0608,1097.8545,2231.09,486.6004,2085.8784,725.49756,596.9133,964.8147,627.002,2138.5535,703.25635,3905.8936,462.25485]
2022-07-21 15:48:37.425323
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ ( (o-e)^2 ) / e | (o, e) <- zip os es]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:49:40.9932
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ ( (o-e)^2 ) / e | (o, e) <- zip os es]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chisqr) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:54:24: error:
    Variable not in scope:
      positions :: ([Float] -> Float) -> [Float] -> [a]
   |
54 |         factor = head (positions (minimum chisqr) chitab)
   |                        ^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:54:56.632581
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ ( (o-e)^2 ) / e | (o, e) <- zip os es]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chisqr) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..]]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:54:43: error:
    • Couldn't match type ‘[Float] -> Float’ with ‘Float’
      Expected: [Float] -> Float
        Actual: [Float] -> [Float] -> Float
    • Probable cause: ‘chisqr’ is applied to too few arguments
      In the first argument of ‘minimum’, namely ‘chisqr’
      In the first argument of ‘positions’, namely ‘(minimum chisqr)’
      In the first argument of ‘head’, namely
        ‘(positions (minimum chisqr) chitab)’
   |
54 |         factor = head (positions (minimum chisqr) chitab)
   |                                           ^^^^^^
Failed, no modules loaded.
2022-07-21 15:58:36.237829
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ ( (o-e)^2 ) / e | (o, e) <- zip os es]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chitab) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..]]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:59:06.983388
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (n + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ ( (o-e)^2 ) / e | (o, e) <- zip os es]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chitab) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..], x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:59:57.233481
>>> positions False [True, False, True, False]
[1,3]
2022-07-21 16:00:25.236681
>>> crack sampleAngou
"haskell is fun"
2022-07-21 16:03:29.789309
>>> crack "vscd mywzboroxcsyxc kbo ecopev"
"list comprehensions are useful"
2022-07-21 16:04:31.403588
>>> encode 5 "pokemon of Nintendo"
"utpjrts tk Nnsyjsit"
2022-07-21 16:05:49.418769
>>> crack "utpjrts tk Nnsyjsit"
"pokemon of Nintendo"
2022-07-21 16:05:59.013755
>>> encode "Kirby in Forgotten Land"

<interactive>:27:8: error:
    • No instance for (Data.String.IsString Int)
        arising from the literal ‘"Kirby in Forgotten Land"’
    • In the first argument of ‘encode’, namely
        ‘"Kirby in Forgotten Land"’
      In the expression: encode "Kirby in Forgotten Land"
      In an equation for ‘it’: it = encode "Kirby in Forgotten Land"
2022-07-21 16:07:14.030904
>>> encode 10 "Kirby in Forgotten Land"
"Ksbli sx Fybqyddox Lkxn"
2022-07-21 16:07:44.607661
>>> crack "Ksbli sx Fybqyddox Lkxn"
"Kirby in Forgotten Land"
2022-07-21 16:08:06.987326
>>> crack "aeoghiu fjpiaw;"
"ycmefgs dhngyu;"
2022-07-21 16:11:55.919598
>>> :q
Leaving GHCi.
